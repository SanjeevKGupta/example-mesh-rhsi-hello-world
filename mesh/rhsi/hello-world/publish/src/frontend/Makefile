#
# Makefile : frontend
#

# Check all necessary environment variables
-include ../../env.var.app.cmd.mk
-include ../../env.var.app.image.mk

# Import variables from hzn.json (file is generated by last target in this file)
-include .hzn.json.tmp.mk

export K_ARCH=${ARCH}
export K_DOCKER_IMAGE=${DOCKER_IMAGE}
export K_SERVICE_VERSION=${SERVICE_VERSION}

all: build push apply_kube

check_var_namespace:
	$(call cmd_var_check,NAMESPACE,as make <target> NAMESPACE=<namespace>)
	@echo ""
	@echo "NAMESPACE: ${NAMESPACE}"
	@echo ""

# Build the docker container
build:
	docker build --platform linux/${ARCH} -t ${DOCKER_IMAGE}_$(ARCH):${SERVICE_VERSION} -f ./Dockerfile.${ARCH} .

test_docker_run:
	@echo "To test, curl in a different terminal"
	@echo "   curl localhost:${K_PORT_BACK}"
	docker run --net=host $(DOCKER_IMAGE)_$(ARCH):$(SERVICE_VERSION)

# Push the docker container to the authenticatd CR
push:
	docker login ${CR_HOST} -u ${CR_HOST_USERNAME} -p ${CR_APP_API_KEY_RW_PUSH}
	docker push $(DOCKER_IMAGE)_$(ARCH):$(SERVICE_VERSION)

-include ../../env.var.app.kube.mk
test_kube_envsubst:
	envsubst < ./kube/deploy-frontend.yaml.tmpl

create_namespace: check_var_namespace
	$(shell kubectl create namespace ${NAMESPACE} > /dev/null 2>&1)

create_image_pull_secret: create_namespace
	$(kubectl delete secret ${K_IMAGE_PULL_SECRET_NAME} -n ${NAMESPACE} > /dev/null 2>&1)
	$(shell kubectl create secret docker-registry ${K_IMAGE_PULL_SECRET_NAME_FRONT} -n ${NAMESPACE} --docker-server=${CR_HOST} --docker-username=${CR_HOST_USERNAME} --docker-password=${CR_APP_API_KEY_RO_PULL} --docker-email="" > /dev/null 2>&1)

apply_kube: create_image_pull_secret
	$(shell kubectl delete deploy ${K_NAME_FRONT} -n ${NAMESPACE} > /dev/null 2>&1)
	envsubst < ./kube/deploy-frontend.yaml.tmpl > ./kube/deploy-frontend.yaml | kubectl apply -n ${NAMESPACE} -f ./kube/deploy-frontend.yaml

# This imports the variables from hzn.json
.hzn.json.tmp.mk: hzn/hzn.json
	@ hzn util configconv -f $< > $@
